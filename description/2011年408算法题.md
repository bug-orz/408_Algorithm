# 2011年408算法题

https://www.codeleading.com/article/17132162648/

## 问题

【问题描述】一个长度为L(L≥1)的升序序列S，处在第[L/2]个位置的数称为S的中位数。

例如，若序列S1=(11，13，15，17，19)，则S1中的中位数是15。

**两个序列的中位数是含它们所有元素的升序序列的中位数。**

例如，若S2=(2，4，6，8，20)，则S1和S2的中位数是11。

现有两个**等长**升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。

【测试样例】S1={11,13,15,17,19}   S2={2,4,6,8,20}
【输出结果】11

## 分析

一个比较容易想到的方法，两个数列各一个指针，从第一个元素开始，谁小移动谁，直到移动L的距离。

时间复杂度O(n)，空间复杂度O(1)

```c++
int mid_search1(int a[], int b[],int L) {
	int i = -1, j = -1, k = L, ans=-1;
	while (k > 0) {
		if (a[i+1] > b[j+1]) {
			j++;
			k--;
			ans = b[j];
		}
		else {
			i++;
			k--;
			ans = a[i];
		}
	}
	return ans;
}
```

另一个方法，分别求两个升序序列A、B的中位数，设为a和b。

1.  若a=b，则a或b即为所求的中位数，算法结束。
2.  若a<b，舍弃A中较小者所在序列之较小一半，同时舍弃B所在序列之较大一半，要求两次舍弃的元素个数相同。
3.  若a>b，舍弃B中较小者所在序列之较小一半，同时舍弃A所在序列之较大一半，要求两次舍弃的元素个数相同。

在保留的两个升序序列中，重复上述过程，直到两个序列中均只含一个元素时为止，则较小者即为所求的中位数。

具体解释：

若a<b时，中位数则肯定不在A的左半边，因为如果在A的左半边则中位数<a<b，即也在B的左半边，在整个S1+S2中
也是在左半边，不是在中点，与中位数矛盾；同理不在B的右半边。
若a>b时，原理同上。
当A长度为奇数时，左半边=右半边，直接舍弃即可
当A长度为偶数时，左半边+1=右半边。若a<b，舍弃A的左半边(包括中点) 舍弃B的右半边(保留中点）
始终保持A,B比较项数相同，即等长

上述算法的时间复杂度为O($\log_2{n}$)，采用空间复杂度为O(1)

```c++
int mid_search2(int A[], int B[], int L) {
    int m1, m2, s1, s2, d1, d2;
    s1 = s2 = 0;
    d1 = d2 = L - 1;
    while (s1 != d1 || s2 != d2)
    {
        m1 = (s1 + d1) / 2;
        m2 = (s2 + d2) / 2;
        if (A[m1] == B[m2])
            return A[m1];
        if (A[m1] < B[m2])//A的中位数比B的中位数小
        {
            if ((s1 + d1) % 2 == 0)//当前比较元素为奇数
            {
                s1 = m1;//A的比较范围向后移动,保留中间点
            }
            else {
                s1 = m1 + 1;//A的比较范围向后移动,不保留中间点
            }
            d2 = m2;//B的比较范围向前移动,保留中间点
        }
        else {//A的中位数比B的中位数大
            d1 = m1;//A的比较范围向前移动,保留中间点
            if ((s2 + d2) % 2 == 0)//当前比较元素为偶数
            {
                s2 = m2;//B的比较范围向后移动,保留中间点
            }
            else {
                s2 = m2 + 1;//B的比较范围向后移动,保留中间点
            }
        }
    }
    if (A[s1] < B[s2])//取小即为中位数点
        return A[s1];
    else return B[s2];

}
```

